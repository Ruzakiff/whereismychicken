<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How Long for Chicken?</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
            position: relative;
            top: -15vh;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 1em;
        }
        .time {
            font-size: 4em;
            font-weight: bold;
            color: #4a4a4a;
        }
        .eastern-time {
            font-size: 1.5em;
            color: #666;
            margin-top: 0.5em;
        }
        .btn {
            margin-top: 1em;
            padding: 0.5em 1em;
            font-size: 1em;
            cursor: pointer;
        }
        #actualTimeInput {
            display: none;
            margin-top: 1em;
        }
        .schedule-container {
            margin-top: 2em;
            width: 90%;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .schedule-table th,
        .schedule-table td {
            padding: 12px 8px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .schedule-table th {
            background: #4a4a4a;
            color: white;
            font-size: 0.9em;
        }

        .schedule-table td {
            font-size: 1.1em;
        }

        .schedule-table tr:last-child td {
            border-bottom: none;
        }

        .current-batch {
            background-color: #f0f8ff;
            font-weight: bold;
        }

        @media (max-width: 380px) {
            .schedule-table th,
            .schedule-table td {
                padding: 8px 4px;
                font-size: 0.9em;
            }
        }

        .schedule-table tr.current-batch {
            background-color: #e3f2fd;  /* Light blue background */
            font-weight: bold;
        }
        
        .schedule-table tr.past-batch {
            color: #999;  /* Gray out past batches */
        }

        .info-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #666;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            color: #666;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            margin-left: 8px;
            vertical-align: middle;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: white;
            padding: 20px;
            border-radius: 20px 20px 0 0;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            z-index: 1001;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content.show {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-close {
            border: none;
            background: none;
            font-size: 24px;
            color: #666;
            padding: 5px;
            cursor: pointer;
        }

        .faq-item {
            margin-bottom: 20px;
        }

        .faq-question {
            font-weight: bold;
            margin-bottom: 8px;
            color: #4a4a4a;
        }

        .faq-answer {
            color: #666;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>How Long for Chicken?</h1>
        <div class="next-ready-label" style="font-size: 1.2em; color: #4a4a4a; margin-bottom: 0.5em;">
            Next oven(s) ready in:
        </div>
        <div class="time" id="countdown"></div>
        <div class="eastern-time" id="eastern-time"></div>
        <div class="prediction-status" id="predictionStatus" style="font-size: 0.8em; color: #666; margin-top: 0.5em;">
            <!-- Will be populated by JavaScript -->
        </div>
        <div class="info-note" style="font-size: 0.8em; color: #666; margin-top: 0.5em; font-style: italic;">
            Based on typical schedule, time may vary due to preparation
            <span class="info-icon" onclick="showInfo()">?</span>
        </div>
        <button class="btn" onclick="showOvenDetails()" style="display: none;">See Oven Details</button>
        <div class="schedule-container">
            <table class="schedule-table">
                <thead>
                    <tr>
                        <th>Oven</th>
                        <th>Target Time</th>
                    </tr>
                </thead>
                <tbody id="scheduleBody">
                    <!-- Will be populated by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>

    <div class="modal-overlay" id="infoModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0; font-size: 1.5em;">Frequently Asked Questions</h2>
                <button class="modal-close" onclick="hideInfo()">&times;</button>
            </div>
            <div class="faq-item">
                <div class="faq-question">What does "Estimated Ready Time" mean?</div>
                <div class="faq-answer">
                    The Estimated Ready Time is our best guess for when the next batch of rotisserie chickens will be ready. We use a combination of the standard schedule and real-time adjustments, so this time may vary slightly from the schedule. Think of it as a close estimate, but not an exact time.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question">Why is there a difference between the Scheduled Time and the Estimated Ready Time?</div>
                <div class="faq-answer">
                    Scheduled times are based on the Club's typical cooking schedule, while the Estimated Ready Time accounts for slight delays or faster preparation due to factors like worker availability. Our goal is to give you a realistic idea of when chickens will be ready, even if it doesn't match the exact schedule.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question">How accurate is the Estimated Ready Time?</div>
                <div class="faq-answer">
                    The Estimated Ready Time is usually accurate within +/- 30 minutes. While we do our best to keep it reliable, unexpected delays can happen. We recommend checking back occasionally if you're planning to pick up a chicken soon.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question">Can I rely on this time to avoid waiting?</div>
                <div class="faq-answer">
                    We hope this tool saves you time, but since it's only an estimate, we can't guarantee it will always be perfectly accurate. Use it as a helpful guide, and check for updates to make sure the timing is still close.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question">Who created this tool?</div>
                <div class="faq-answer">
                    This tool was created by a Costco employee to help members get a better idea of when rotisserie chickens will be ready. It's not an official Costco service but is designed to make your shopping experience easier.
                </div>
            </div>
            <!-- <div class="faq-item">
                <div class="faq-question">Can I support this tool?</div>
                <div class="faq-answer">
                    If you find this tool helpful, consider making a small donation to support its maintenance. Donations help keep the tool running and improve its accuracy.
                </div>
            </div> -->
        </div>
    </div>

    <script>
        let targetTime = null;

        function showOvenDetails() {
            window.location.href = '/ovens';
        }

        function updateCountdown() {
            if (!targetTime) {
                fetchPrediction();
                return;
            }

            const now = new Date();
            const timeDiff = targetTime - now;

            if (timeDiff <= 0) {
                // Time's up - fetch new prediction and update schedule
                fetchPrediction();
                loadSchedule();
                return;
            }

            // Regular countdown update
            const hours = Math.floor(timeDiff / 3600000);
            const minutes = Math.floor((timeDiff % 3600000) / 60000);
            const seconds = Math.floor((timeDiff % 60000) / 1000);

            if (hours > 0) {
                document.getElementById('countdown').textContent = `${hours}h ${minutes}m`;
            } else {
                document.getElementById('countdown').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function updateSchedule(data) {
            const scheduleBody = document.getElementById('schedule-body');
            scheduleBody.innerHTML = '';

            if (!data || !data.batches || data.batches.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="3">No active batches</td>';
                scheduleBody.appendChild(row);
                return;
            }

            data.batches.forEach(batch => {
                const row = document.createElement('tr');
                const startTime = new Date(batch.start_time);
                const readyTime = new Date(batch.ready_time);
                
                // Format times in 12-hour format
                const formatTime = (date) => {
                    return date.toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    }).toLowerCase();
                };

                // Add 'current-batch' class if this is the next ready batch
                if (batch.is_next) {
                    row.classList.add('current-batch');
                }

                row.innerHTML = `
                    <td>${batch.number}</td>
                    <td>${formatTime(startTime)}</td>
                    <td>${formatTime(readyTime)}</td>
                `;
                scheduleBody.appendChild(row);
            });
        }

        function updateDisplay(data) {
            console.log('Received data:', data);
            
            if (data.earliest_time) {
                targetTime = new Date(data.earliest_time);
                const now = new Date();
                if (targetTime.getDate() !== now.getDate()) {
                    document.getElementById('countdown').textContent = "Next batch tomorrow";
                } else if (!data.is_open) {
                    document.getElementById('countdown').textContent = "Store closed";
                } else {
                    document.getElementById('eastern-time').textContent = targetTime.toLocaleTimeString('en-US', { timeZone: 'America/New_York' });
                    updateCountdown();
                }

                // Update prediction status message
                const statusElement = document.getElementById('predictionStatus');
                if (data.is_confirmed) {
                    const updateTime = new Date(data.last_manual_update);
                    const timeStr = updateTime.toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    }).toLowerCase();
                    statusElement.textContent = `Recently confirmed at ${timeStr}`;
                    statusElement.style.color = '#2e7d32';  // dark green
                } else {
                    statusElement.textContent = 'Estimated Time based on schedule';
                    statusElement.style.color = '#666';  // gray
                }
                statusElement.style.display = 'block';
            } else {
                document.getElementById('countdown').textContent = "No prediction available";
                document.getElementById('eastern-time').textContent = "";
                document.getElementById('predictionStatus').style.display = 'none';
                targetTime = null;
            }

            // Update schedule
            updateSchedule(data);

            // Reload schedule to update highlighting
            loadSchedule();
        }

        function fetchPrediction() {
            fetch('/predict')
                .then(response => response.json())
                .then(data => {
                    console.log('Fetched data:', data);
                    updateDisplay(data);
                })
                .catch(error => console.error('Error:', error));
        }

        // Initial fetch
        fetchPrediction();

        // Update countdown every second
        setInterval(updateCountdown, 1000);

        // Fetch new prediction every minute
        setInterval(fetchPrediction, 60000);

        // Add this with your other JavaScript
        const evtSource = new EventSource("/events");
        
        evtSource.onopen = function(event) {
            console.log('SSE connection opened');
        };
        
        evtSource.onerror = function(event) {
            console.log('SSE connection error:', event);
        };
        
        evtSource.onmessage = function(event) {
            console.log('SSE message received:', event.data);
            if (event.data === "update") {
                // Force immediate update
                fetchPrediction();
                // Reset the interval timer to avoid quick double updates
                clearInterval(updateInterval);
                updateInterval = setInterval(fetchPrediction, 60000);
            }
        };

        // Store interval ID so we can reset it
        let updateInterval = setInterval(fetchPrediction, 60000);

        // Initial update
        fetchPrediction();

        // Add this to your existing JavaScript
        function loadSchedule() {
            // First get the current prediction
            fetch('/predict')
                .then(response => response.json())
                .then(predictionData => {
                    // Then load and process the schedule
                    return fetch('/schedule')
                        .then(response => response.json())
                        .then(scheduleData => processSchedule(scheduleData, predictionData));
                })
                .catch(error => {
                    console.error('Error:', error);
                    document.getElementById('scheduleBody').innerHTML = 
                        '<tr><td colspan="2">Unable to load schedule</td></tr>';
                });
        }

        function processSchedule(data, predictionData) {
            const scheduleBody = document.getElementById('scheduleBody');
            scheduleBody.innerHTML = '';
            
            if (!data.schedule || !predictionData.earliest_time) return;
            
            const now = new Date();
            const predictedTime = new Date(predictionData.earliest_time);
            
            data.schedule.forEach(([oven, scheduledTime]) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${oven}</td><td>${scheduledTime}</td>`;
                
                // Convert schedule time to comparable format
                const [time, period] = scheduledTime.split(' ');
                const [hours, minutes] = time.split(':');
                let scheduleHours = parseInt(hours);
                if (period.toLowerCase() === 'pm' && scheduleHours !== 12) {
                    scheduleHours += 12;
                } else if (period.toLowerCase() === 'am' && scheduleHours === 12) {
                    scheduleHours = 0;
                }
                
                const scheduleDate = new Date();
                scheduleDate.setHours(scheduleHours, parseInt(minutes), 0, 0);
                
                // First principles:
                // 1. If predicted time is within 60 minutes BEFORE a scheduled time, it's the next batch
                // 2. If predicted time is within 90 minutes AFTER a scheduled time, it's this batch
                // 3. Otherwise, look for the closest scheduled time
                
                const timeDiffMinutes = (predictedTime - scheduleDate) / (1000 * 60);
                
                if (timeDiffMinutes >= 0 && timeDiffMinutes <= 90) {
                    // This is the current batch running late
                    row.classList.add('current-batch');
                } else if (scheduleDate < now && !row.classList.contains('current-batch')) {
                    // This batch is in the past
                    row.classList.add('past-batch');
                }
                
                scheduleBody.appendChild(row);
            });
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', loadSchedule);

        function showInfo() {
            const modal = document.getElementById('infoModal');
            const content = modal.querySelector('.modal-content');
            modal.style.display = 'block';
            // Trigger reflow before adding show class for animation
            content.offsetHeight;
            content.classList.add('show');
        }

        function hideInfo() {
            const modal = document.getElementById('infoModal');
            const content = modal.querySelector('.modal-content');
            content.classList.remove('show');
            // Wait for animation to finish before hiding modal
            setTimeout(() => {
                modal.style.display = 'none';
            }, 300);
        }

        // Close modal when clicking overlay
        document.getElementById('infoModal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideInfo();
            }
        });
    </script>
</body>
</html>



